<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.materialdesignicons.com/3.6.95/css/materialdesignicons.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans:200,400,700"> 
    <!-- <link href="static/main.css" rel="stylesheet"> -->
    
  </head>
  <body>
    <div id="app">
      <v-app>
        <v-container fluid overflow-auto>
          <v-layout fill-height>
            <v-flex xs3 mr-3 overflow-hidden>
              <v-layout column white pa-2 fill-height overflow-auto>
                <v-flex>
                  <v-layout column>
                    <v-select label="Select group" :items="ai_players" v-model="selected_ai" outline></v-select>
                    <v-flex headline>Group info</v-flex>
                    <v-flex subheading font-weight-bold mt-2>name</v-flex>
                    <v-flex body-1>{{ current_ai.name }}</v-flex>
                    <v-flex subheading font-weight-bold mt-2>icon</v-flex>
                    <v-flex body-1><span :class="['mdi', 'mdi-'+current_ai.icon]"></span></v-flex>
                    <v-flex subheading font-weight-bold mt-2>member</v-flex>
                    <v-flex body-1 v-for="member in current_ai.members">{{ member }}</v-flex>
                    <v-flex subheading font-weight-bold mt-2>games</v-flex>
                    <v-data-table :headers="one_ai_table_header" :items="one_ai_table_items" item-key="game_num">
                      <template v-slot:items="props">
                        <tr @click="props.expanded = !props.expanded">
                          <td>{{ props.item.game_num }}</td>
                          <td>{{ props.item.points }}</td>
                        </tr>
                      </template>
                      <template v-slot:expand="props">
                        <v-card class="pa-2">
                          <v-data-table class="elevation-3" hide-headers hide-actions :items="formatDetails(props.item.details)">
                            <template v-slot:items="props">
                              <tr>
                                <td>{{ props.item.label }}</td>
                                <td>{{ props.item.value }}</td>
                              </tr>
                            </template>
                          </v-data-table>
                        </v-card>
                      </template>
                    </v-data-table>
                  </v-layout>
                </v-flex>
              </v-layout>
            </v-flex>
            <v-flex xs9 shrink overflow-hidden>
              <v-layout column fill-height>
                <v-flex mb-3 white display-4 shrink>
                  <v-layout row align-content-center my-5>
                    <v-spacer></v-spacer>
                    <v-flex shrink text-xs-center mx-2 v-for="d,i in dice_face" :class="just_rolled[i] == 1 ? 'just-rolled' : 'not-rolled'"><span :class="['mdi', 'mdi-dice-'+d]"></span></v-flex>
                    <v-spacer></v-spacer>
                  </v-layout>
                </v-flex>
                <v-flex display-3 mb-3 white shrink>
                  <v-layout row justify-center>
                    <v-spacer></v-spacer>
                    <v-spacer></v-spacer>
                    <v-btn icon large fab title="autorun this game" @click="runAGame" :disabled="!can_game_continue"><v-icon>mdi-play</v-icon></v-btn>
                    <v-spacer></v-spacer>
                    <v-btn icon large fab title="roll once" @click="rollOnce" :disabled="!can_game_continue"><v-icon>mdi-skip-next</v-icon></v-btn>
                    <v-spacer></v-spacer>
                    <v-btn icon large fab title="autorun all games"><v-icon>mdi-play-circle-outline</v-icon></v-btn>
                    <v-spacer></v-spacer>
                    <v-btn icon large fab title="new game" @click="newGame"><v-icon>mdi-new-box</v-icon></v-btn>
                    <v-spacer></v-spacer>
                    <v-spacer></v-spacer>
                  </v-layout>
                </v-flex>
                <v-flex white overflow-auto>
                  <v-layout column px-2>
                    <template v-for="message,i in messages">
                      <v-flex my-2>{{ message }}</v-flex>
                      <v-divider v-if="i < messages.length-1"></v-divider>
                    </template>
                  </v-layout>
                </v-flex>
              </v-layout>
            </v-flex>
          </v-layout>
        </v-container>
      </v-app>
    </div>
    
    <style>
      html, body { width: 100vw; height: 100vh; overflow: auto; display: flex; }
      #app { flex-grow: 1; display: flex; }
      .overflow-auto { overflow: auto; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <!-- <script src="static/vue.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/vuetify/dist/vuetify.js"></script>
    <script>
      var app = new Vue({
        el: '#app',
        data: {
          ai_players: ['a','b','c'],
          selected_ai: 'b',
          ai_info: [{
            name: 'group name',
            icon: 'b',
            members: ['member', 'member2']
          }],
          dice_number: 5,
          dice_face: [1,2,3,4,5],
          just_rolled: [1,0,0,0,0],
          ai_players: [],
          current_game_init: {
            rolled: [],
            reroll_index: []
          },
          one_ai_table_header: [
            { text: 'Game', value: 'game_num', align: 'center', sortable: false },
            { text: 'Points', value: 'points', align: 'center', sortable: false },
          ]
        },
        computed: {
          current_ai: function () {
            let c_ai = this.ai_info.find(x => x.module == this.selected_ai);
            return c_ai ? c_ai : { name: '', module: this.selected_ai, icon: '', members: [], games: [] }
          },
          messages: function () {
            let m = [];
            this.current_game.rolled.forEach((v, i) => {
              m.push("rolled dice: " + v.join(', '));
              if (this.current_game.reroll_index[i]) {
                m.push("to reroll: " + this.current_game.reroll_index[i].join(', '));
              }
            });
            return m;
          },
          current_game: function () {
            return this.current_ai.games[this.current_ai.games.length - 1] || JSON.parse(JSON.stringify(this.current_game_init));
          },
          can_game_continue: function () {
            return this.current_game.rolled.length < 6 & (this.current_game.reroll_index.length > 0 ?  this.current_game.reroll_index[this.current_game.reroll_index.length - 1].length > 0 : true);
          },
          one_ai_table_items: function () {
            return this.current_ai.games.map((x, i) => ({
              game_num: i+1,
              points: this.getPoints(x.rolled[x.rolled.length - 1]),
              details: x
            }));
          }
        },
        mounted: function () {
          this.getAiList()
            .then(r => {
              this.selected_ai = this.ai_players[0];
              return r;
            })
            .then(this.initAllAiPlayers)
            .then(r => {
              this.ai_info = [];
              this.ai_info.push(...r);
              return r;
            })
            .then(console.log);
        },
        methods: {
          getAiList: function() {
            const request = new Request('./get-ai-players');
            return fetch(request)
            .then(r => r.json())
            .then(r => {
              this.ai_players = r;
              return r;
            });
          },
          initAiPlayer: function (ai_name) {
            const request = new Request(`./init-ai-player/${ai_name}`);
            return fetch(request)
              .then(r => {
                return r.json()
              })
              .then(r => {
                if (r.error) {
                  console.error(r.error_msg);
                  return Promise.reject(r.error_msg);
                } else {
                  console.log(r.msg);
                  return Promise.resolve(r);
                }
              });
          },
          initAllAiPlayers: function () {
            return Promise.all(this.ai_players.map(x => this.initAiPlayer(x).then(r => ({
              name: r.group_name,
              module: x,
              icon: r.group_icon,
              members: r.group_members,
              games: [JSON.parse(JSON.stringify(this.current_game_init))]
            }))));
          },
          rollDice: function (dice_index) {
            for (let i = 0; i < dice_index.length; i++) {
              let rolled = Math.max(1, Math.ceil(Math.random()*6));
              this.$set(this.dice_face, dice_index[i], rolled);
            }
            this.current_ai.games[this.current_ai.games.length - 1].rolled.push(JSON.parse(JSON.stringify(this.dice_face)));
          },
          newGame: function() {
            console.log(JSON.stringify(this.current_ai.games[this.current_ai.games.length - 1]), JSON.stringify(this.current_game_init))
            if (JSON.stringify(this.current_ai.games[this.current_ai.games.length - 1]) !== JSON.stringify(this.current_game_init)) {
              this.current_ai.games.push(JSON.parse(JSON.stringify(this.current_game_init)));
            }
          },
          requestNextReroll: function () {
            console.log(this.current_ai.module, this.dice_face);
            const request = new Request(`./call-ai-player/${this.current_ai.module}/${this.dice_face.join(',')}/${6 - this.current_game.rolled.length}`);
            return fetch(request)
              .then(r => {
                return r.json()
              })
              .then(r => {
                if (r.error) {
                  console.error(r.error_msg);
                  return Promise.reject(r.error_msg);
                } else {
                  console.log(r.msg);
                  this.current_game.reroll_index.push(r.reroll_dice)
                  return Promise.resolve(r.reroll_dice);
                }
              });
          },
          rollOnce: function () {
            if (this.current_game.reroll_index.length > 0) {
              this.rollDice(this.current_game.reroll_index[this.current_game.reroll_index.length - 1]);
            } else {
              this.rollDice([...Array(this.dice_number).keys()]);
            }
            if (this.can_game_continue) return this.requestNextReroll().then(() => true);
            else return Promise.resolve(false);
          },
          runAGame: function () {
            rag = () => this.rollOnce()
              .then(r => {
                if (r) {
                  return rag();
                } else {
                  Promise.resolve()
                }
              })
            return rag();
          },
          getPoints: function (dice_face) {
            return dice_face ? dice_face.reduce((acc, v) => acc + v, 0) : 0;
          },
          formatDetails: function (details) {
            let m = [];
            details.rolled.forEach((v, i) => {
              m.push({ label: 'rolled', value: v.join(', ') });
              if (details.reroll_index[i]) {
                m.push({ label: 'reroll', value: details.reroll_index[i].join(', ') });
              }
            });
            return m;
          }
        }
      })
    </script>
  </body>
</html>